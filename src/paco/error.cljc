(ns paco.error
  (:require [clojure.string :as str])
  (:import #?(:clj [java.io StringWriter]
              :cljs [goog.string StringBuffer])))

(defn- write! [writer s]
  #?(:clj  (.write ^java.io.Writer writer (str s))
     :cljs (-write writer (str s))))

(def ^:private type-priority
  (zipmap [::expected
           ::expected-input
           ::unexpected
           ::unexpected-input
           ::message
           ::nested
           ::compound
           ::other]
          (range)))

(defn- compare-types [t1 t2]
  (let [p1 (type-priority t1)
        p2 (type-priority t2)]
    (if (nil? p1)
      (if (nil? p2)
        (compare t1 t2)
        1)
      (if (nil? p2)
        -1
        (compare p1 p2)))))

(defprotocol IMessage
  (-type [msg])
  (-render [msg writer opts])
  (-msg-compare [msg other]))

(defrecord Label [type label]
  IMessage
  (-type [_] type)
  (-render [_ writer _opts] (write! writer label))
  (-msg-compare [_ other]
    (let [d (compare-types type (-type other))]
      (if (zero? d)
        (compare label (.-label ^Label other))
        d))))

(defrecord Input [type input]
  IMessage
  (-type [_] type)
  (-render [_ writer _opts]
    (let [quote (if (str/includes? input "'") "\"" "'")]
      (write! writer quote)
      (write! writer input)
      (write! writer quote)))
  (-msg-compare [_ other]
    (let [d (compare-types type (-type other))]
      (if (zero? d)
        (compare input (.-input ^Input other))
        d))))

(declare sort-messages write-messages!)

(defrecord Nested [type label pos user-state msgs]
  IMessage
  (-type [_] type)
  (-render [_ writer opts]
    (if label
      (do
        (write! writer label)
        (write! writer " could not be parsed because: "))
      (write! writer "backtracked after: "))
    (write-messages! writer msgs pos opts))
  (-msg-compare [_ other]
    (let [d (compare-types type (-type other))]
      (if (zero? d)
        ;; TODO: Ensure `pos` is comparable
        (let [d (compare pos (.-pos ^Nested other))]
          (if (zero? d)
            (compare (sort-messages msgs)
                     (sort-messages (.-msgs ^Nested other)))
            d))
        d))))

(defn expected
  "The input does not match the expected input.

   `label` describes the expected input."
  [label]
  (->Label ::expected (str label)))

;; fparsec: + ExpectedCaseInsensitiveString
(defn expected-input
  "The input does not match an expected string constant."
  [input]
  (->Input ::expected-input (str input)))

(defn unexpected
  "The parser encountered some unexpected input."
  [label]
  (->Label ::unexpected (str label)))

;; fparsec: + UnexpectedCaseInsensitiveString
(defn unexpected-input
  "The parser encountered some unexpected input."
  [input]
  (->Input ::unexpected-input (str input)))

(defn message
  "The error does not fit the other types."
  [text]
  (->Label ::message (str text)))

(defn nested
  "Backtracked after an error occurred."
  [pos user-state msgs]
  (->Nested ::nested nil pos user-state msgs))

(defn compound
  "Mainly generated by compound-labelling operator."
  [label pos user-state msgs]
  (->Nested ::compound (str label) pos user-state msgs))

;; fparsec: + Other

(def ^:private eof-label "end of input")
(def unexpected-eof (unexpected eof-label))
(def expected-eof (expected eof-label))

(defprotocol IMessageColl
  (-collect [coll f result]))

(defn- collect-msgs [msgs f result]
  (cond
    ;; TODO: Filter empty Label and Input messages?
    (satisfies? IMessage msgs) (f result msgs)
    (satisfies? IMessageColl msgs) (-collect msgs f result)
    ;; Assume a flat collection returned by `message-set`,
    ;; we don't support nested collections.
    :else (reduce f result msgs)))

(deftype Union [m1 m2]
  IMessageColl
  (-collect [_ f result]
    (->> result (collect-msgs m1 f) (collect-msgs m2 f))))

(defn union [m1 m2]
  (Union. m1 m2))

;; fparsec: ToHashSet
(defn message-set [msgs]
  (persistent! (collect-msgs msgs conj! (transient #{}))))

;; fparsec: ToSortedArray
(defn sort-messages [msgs]
  (sort -msg-compare (message-set msgs)))

(def ^:private type-group
  {::expected ::expected
   ::expected-input   ::expected
   ::unexpected ::unexpected
   ::unexpected-input ::unexpected
   ::nested ::nested
   ::compound ::compound})

(defn- msg-group [msg]
  (type-group (-type msg) ::other))

(defn- write-list! [writer prefix sep msgs opts]
  (when-let [m (first msgs)]
    (write! writer prefix)
    (-render m writer opts)
    (when-let [ms (next msgs)]
      (doseq [m (butlast ms)]
        (write! writer ", ")
        (-render m writer opts))
      (write! writer sep)
      (-render (last ms) writer opts))))

;; TODO: Options: multiline ('\n' or ';'), prefix such as "Parse Error: "
;; TODO: Pretty-printing with source line and ^ marker
(defn write-messages!
  ([writer msgs]
   (write-messages! writer msgs nil))
  ([writer msgs pos]
   (write-messages! writer msgs pos nil))
  ([writer msgs pos opts]
   (let [{:keys [sep] :or {sep "; "}} opts
         {::keys [expected unexpected message nested compound _other]
          :as grouped}
         (group-by msg-group (sort-messages msgs))]
     (write-list! writer "expected " " or " expected opts)
     ;; TODO: Use a custom Writer that can track writes,
     ;; so that we can do (maybe-newline)
     (when (seq unexpected)
       (when (seq expected)
         (write! writer sep))
       (write-list! writer "unexpected " " and " unexpected opts))
     (when (seq message)
       (write! writer sep)
       (write! writer "Other error messages: ")
       (doseq [msg message]
         (-render msg writer opts)))
     (doseq [msg compound]
       (write! writer sep)
       (-render msg writer opts))
     (when (empty? grouped)
       (write! writer "Unknown error(s)"))
     (doseq [msg nested]
       (write! writer sep)
       (-render msg writer opts))
     (when pos
       (write! writer " at ")
       (write! writer pos)))))

(defn string
  ([msgs]
   (string msgs nil))
  ([msgs pos]
   #?(:clj (with-open [writer (StringWriter.)]
             (write-messages! writer msgs pos)
             (.flush writer)
             (str writer))
      :cljs (let [sb (StringBuffer.)
                  writer (StringBufferWriter. sb)]
              (write-messages! writer msgs pos)
              (-flush writer)
              (str sb)))))

(comment
  (string unexpected-eof)
  (string [(expected "something better")
           unexpected-eof])
  (string (union (expected "something better")
                 (union (unexpected-input "x")
                        (union
                         (unexpected-input \x)
                         unexpected-eof))))

;;
  )
